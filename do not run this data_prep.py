'''
    data_prep.py contains:
        (1) Class IoT_Device loads data from the datasets
        (2) Runs prediction models:
            a) LogisticRegression
'''
import os
import pandas as pd

from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.impute import SimpleImputer
from sklearn.utils import resample
from sklearn.decomposition import PCA
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import plot_confusion_matrix

import matplotlib.pyplot as plt
import seaborn as sns

import itertools

def list_iot_devices():
    # List of all IoT devices for which data was collcted
    device_list = {"Door_Bell": {"Damini_Doorbell":1, "Ennino_Doorbell":2},
               "Thermostats": {"Ecobee_Thermostat":1},
               "Baby_Monitor": {"Philips_B120N10_Baby_Monitor":1},
               "Security_Camera": {"Provision_PT_737E_Security_Camera":1,
                                   "Provision_PT_838_Security_Camera":2,
                                   "SimpleHome_XCS7_1002_WHT_Security_Camera":3,
                                   "SimpleHome_XCS7_1003_WHT_Security_Camera":4}}
   
    print("{:<17} {:<41} {:<60}".format('_______________','________________________________________','______'))
    print("{:<17} {:<41} {:<60}".format('Decice Category','Device','Number'))
    print("{:<17} {:<41} {:<60}".format('_______________','________________________________________','______'))
    
    for device,iots in device_list.items():
        for iot,val in device_list[device].items():
            print("{:<17} {:<41} {:<60}".format(device, iot, val)) 


class IoT_Device:
    '''


    '''
    def __init__(self,device):  
        self.device = device
        self.iot_dataframe()
        self.threat_class_dict = {"Class": {"Benign":0, "Mirai_ACK":1, "Mirai_SCAN":2, "Mirai_SYN":3, "Mirai_UDP":4, "Mirai_UDPPLAIN":5,
                            "Gafgyt_COMBO":6, "Gafgyt_JUNK":7, "Gafgyt_SCAN":8, "Gafgyt_TCP":9, "Gafgyt_UDP":10}}
        
    def create_df (self, filename):
        '''
            Method: Create_df
            Input: filename, device
            Action: Read filename and return datafram
        '''
        df = {}
        if os.path.exists(filename):
            df = pd.read_csv(filename)
        else:
            print("{} datafile does not exist for {}".format(filename, self.device))
        return df  
   
    def iot_dataframe(self):
        '''

        '''    
        # First path to benign, mirai, gafgyt data files
        print(f"Preparing data for ***** {self.device} *****")
        benign_data = "../../data/"+ self.device +"/benign_traffic.csv"
        mirai_path = "../../data/"+ self.device +"/mirai_attacks/"
        gafgyt_path = "../../data/"+ self.device +"/gafgyt_attacks/"
    
        #Benign dataframe
        df_benign = self.create_df(benign_data)
        df_benign['Class'] = "Benign"

        '''
            For the device, create mirai dataframes for ack, scan, syn, udp, udpplain attack files
        '''
        # 1. ack.csv
        fn = mirai_path+"ack.csv"
        df_mirai_ack = self.create_df(benign_data)
        df_mirai_ack['Class'] = 0
        
        #2 scan.csv    
        fn = mirai_path+"scan.csv"
        df_mirai_scan = self.create_df(fn)
        df_mirai_scan['Class'] = 1 
        
        #3 syn.csv    
        fn = mirai_path+"syn.csv"        
        df_mirai_syn = self.create_df(fn)       
        df_mirai_syn['Class'] = 1
        
        #4 udp.csv    
        fn = mirai_path+"udp.csv"
        df_mirai_udp = self.create_df(fn) 
        df_mirai_udp['Class'] = 1
    
        #5 udpplain.csv    
        fn = mirai_path+"udpplain.csv"
        df_mirai_udpplain = self.create_df(fn) 
        df_mirai_udpplain['Class'] = 1
        
        '''
            For the device, create gafgyt attack dataframes for ack, scan, syn, udp, udpplain attack data files
        '''
        # 1. combo.csv
        fn = gafgyt_path+"combo.csv"
        df_gafgyt_combo = self.create_df(fn) 
        df_gafgyt_combo['Class'] = 2
        
        #2 junk.csv    
        fn = gafgyt_path+"junk.csv"
        df_gafgyt_junk = self.create_df(fn) 
        df_gafgyt_junk['Class'] = 2
        
        #3 scan.csv    
        fn = gafgyt_path+"scan.csv"
        df_gafgyt_scan = self.create_df(fn) 
        df_gafgyt_scan['Class'] = 2

        #4 tcp.csv    
        fn = gafgyt_path+"tcp.csv"
        df_gafgyt_tcp = self.create_df(fn) 
        df_gafgyt_tcp['Class'] = 2
    
        #5 udp.csv    
        fn = gafgyt_path+"udp.csv"
        df_gafgyt_udp = self.create_df(fn) 
        df_gafgyt_udp['Class'] = 2
        
        lst_df = [df_benign, df_mirai_ack, df_mirai_scan, df_mirai_syn, df_mirai_udp, df_mirai_udpplain,
                  df_gafgyt_combo, df_gafgyt_junk, df_gafgyt_scan, df_gafgyt_tcp, df_gafgyt_udp]
        
        
        mirai_df = pd.concat([df_mirai_ack, df_mirai_scan, df_mirai_syn, df_mirai_udp, df_mirai_udpplain], ignore_index=False)
        gafgyt_df = pd.concat([df_gafgyt_combo, df_gafgyt_junk, df_gafgyt_scan, df_gafgyt_tcp, df_gafgyt_udp], ignore_index=False)

        print("\nBefore --- Benign: {}     Mirai Malware: {}     Gafgyt Malware: {} ".format(len(df_benign), len(mirai_df), len(gafgyt_df)))
        
        mirai_df = mirai_df.sample(len(df_benign))
        gafgyt_df = gafgyt_df.sample(len(df_benign))       
        print("\nAfter--- Benign: {}     Mirai Malware: {}     Gafgyt Malware: {} ".format(len(df_benign), len(mirai_df), len(gafgyt_df)))
            
        
        #Create the massive dataframe with everything for the IoT device
        data = pd.concat([df_benign, mirai_df, gafgyt_df], ignore_index=False)  

        # Save target(y) and predictors(X) as class variables
        self.X = data.drop("Class", axis=1)
        self.y = data["Class"]

        
        # EDA processing goes here      
#         # Let's store training and testing data in the class itself for use when we test several models
#         self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X, y, random_state = 42, test_size = 0.30)

    def iot_convert_target_values(self, binary):
        if binary == True:
            threat_class = {"Benign":0, "Mirai_ACK":1, "Mirai_SCAN":1, "Mirai_SYN":1, "Mirai_UDP":1, "Mirai_UDPPLAIN":1,
                            "Gafgyt_COMBO":1, "Gafgyt_JUNK":1, "Gafgyt_SCAN":1, "Gafgyt_TCP":1, "Gafgyt_UDP":1}
            self.y = self.y.replace(threat_class) 
        else:
            threat_class = {0:"Benign", 1:"Mirai_ACK", 2:"Mirai_SCAN", 3:"Mirai_SYN", 4:"Mirai_UDP", 5:"Mirai_UDPPLAIN",
            6:"Gafgyt_COMBO", 7:"Gafgyt_JUNK", 8:"Gafgyt_SCAN", 9:"Gafgyt_TCP", 10:"Gafgyt_UDP"}
            self.y = self.y.replace(threat_class)        
        
        
    def iot_FSM (self): 
        '''
            IoT_FSM method will perform a first simple model with LogisticRegression with all default parameters, except max_iter=1000 otherwise cpu is going crazy
            
            Method: IoT_FSM
            Input: None
            Action: 1) Change target to binary, for FSM only.
                    2) Instantiate LogisticRegression classifier
                    3) Fit model
                    4) Run cross_val_score
        '''       

        # Istantiate Logistic Regression classifier
        lg_fsm = LogisticRegression()
        lg_fsm.fit(self.X, self.y)        
        self.y_hat = lg_fsm.predict(self.X)
        
        
        
        
        
        cm = confusion_matrix(self.y, self.y_hat)        
        
        fig, ax = plt.subplots()
        sns.heatmap(cm, ax=ax, annot=True,  square=True, 
            cbar=False, cmap="coolwarm", fmt='g',
            xticklabels=['Benign', 'Mirai', 'Gafgyt'],yticklabels=['Benign', 'Mirai', 'Gafgyt'] )
        ax.set_xlabel('Predicted', fontdict={'size': 15})
        ax.set_ylabel('True', fontdict={'size': 15})
        ax.set_title('Logistic Regression: FSM', fontdict={'size': 15})

        ax.set_xlabel('Predicted', fontdict={'size': 15})
        ax.set_ylabel('True', fontdict={'size': 15})
        ax.set_title('Logistic Regression: FSM', fontdict={'size': 15})
        self.lg_fsm = lg_fsm

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
#______ SAVE temporarily
#     def iot_dataframe(self):
#         '''

#         '''    
#         # First path to benign, mirai, gafgyt data files
#         print(f"Preparing data for ***** {self.device} *****")
#         benign_data = "../../data/"+ self.device +"/benign_traffic.csv"
#         mirai_path = "../../data/"+ self.device +"/mirai_attacks/"
#         gafgyt_path = "../../data/"+ self.device +"/gafgyt_attacks/"
    
#         #Benign dataframe
#         df_benign = self.create_df(benign_data)
#         df_benign['Class'] = "Benign"

#         '''
#             For the device, create mirai dataframes for ack, scan, syn, udp, udpplain attack files
#         '''
#         # 1. ack.csv
#         fn = mirai_path+"ack.csv"
#         df_mirai_ack = self.create_df(benign_data)
#         df_mirai_ack['Class'] = "Mirai_ACK"
        
#         #2 scan.csv    
#         fn = mirai_path+"scan.csv"
#         df_mirai_scan = self.create_df(fn)
#         df_mirai_scan['Class'] = "Mirai_SCAN"  
        
#         #3 syn.csv    
#         fn = mirai_path+"syn.csv"        
#         df_mirai_syn = self.create_df(fn)       
#         df_mirai_syn['Class'] = "Mirai_SYN"
        
#         #4 udp.csv    
#         fn = mirai_path+"udp.csv"
#         df_mirai_udp = self.create_df(fn) 
#         df_mirai_udp['Class'] = "Mirai_UDP"
    
#         #5 udpplain.csv    
#         fn = mirai_path+"udpplain.csv"
#         df_mirai_udpplain = self.create_df(fn) 
#         df_mirai_udpplain['Class'] = "Mirai_UDPPLAIN"
        
#         '''
#             For the device, create gafgyt attack dataframes for ack, scan, syn, udp, udpplain attack data files
#         '''
#         # 1. combo.csv
#         fn = gafgyt_path+"combo.csv"
#         df_gafgyt_combo = self.create_df(fn) 
#         df_gafgyt_combo['Class'] = "Gafgyt_COMBO"
        
#         #2 junk.csv    
#         fn = gafgyt_path+"junk.csv"
#         df_gafgyt_junk = self.create_df(fn) 
#         df_gafgyt_junk['Class'] = "Gafgyt_JUNK"
        
#         #3 scan.csv    
#         fn = gafgyt_path+"scan.csv"
#         df_gafgyt_scan = self.create_df(fn) 
#         df_gafgyt_scan['Class'] = "Gafgyt_SCAN"

#         #4 tcp.csv    
#         fn = gafgyt_path+"tcp.csv"
#         df_gafgyt_tcp = self.create_df(fn) 
#         df_gafgyt_tcp['Class'] = "Gafgyt_TCP"
    
#         #5 udp.csv    
#         fn = gafgyt_path+"udp.csv"
#         df_gafgyt_udp = self.create_df(fn) 
#         df_gafgyt_udp['Class'] = "Gafgyt_UDP"
        
#         lst_df = [df_benign, df_mirai_ack,df_mirai_syn, df_mirai_udp, df_mirai_udpplain,
#                   df_gafgyt_combo, df_gafgyt_junk, df_gafgyt_scan, df_gafgyt_tcp, df_gafgyt_udp]
        
#         len_lst = []
#         min_records = min([len_lst.append(len(df)) for df in lst_df])
#         print(f"sampling {min_rcords} in every datafile")                  

            
        
#         #Create the massive dataframe with everything for the IoT device
#         data = pd.concat(lst_df, ignore_index=False)  
        
#         val = data['Class'].value_counts()

#         print( "\nMulti-Classification target category:\n", val)
#         print( "\n\nMinimum number of records: {}  Maximium number of records: {}".format(val.min(), val.max()))     
                
#         # Save target(y) and predictors(X) as class variables
#         self.X = data.drop("Class", axis=1)
#         self.y = data["Class"]
        
#         # Replace Classification to Numberic 
#         self.iot_convert_target_values(True)
        
#         val = self.y.value_counts()
#         print( "\n\nBinary category: {} number of records\n", val)
#         print( "\nMinimum number of records: {}  Maximium number of records: {}".format(val.min(), val.max()))
        
#         # EDA processing goes here      
# #         # Let's store training and testing data in the class itself for use when we test several models
# #         self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X, y, random_state = 42, test_size = 0.30)