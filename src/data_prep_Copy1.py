'''
    data_prep.py contains:
        (1) Class IoT_Device loads data from the datasets
        (2) Runs prediction models:
            a) LogisticRegression
'''
import os
import sys
sys.path.append("../")
import pandas as pd
import numpy as np
import pickle
from sklearn.utils import resample
from sklearn.dummy import DummyClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.impute import SimpleImputer
from sklearn.decomposition import PCA
from sklearn.neighbors import KNeighborsClassifier
from xgboost import XGBClassifier
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.metrics import confusion_matrix, classification_report
from yellowbrick.classifier import ClassificationReport # conda install -c districtdatalabs yellowbrick
from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import plot_confusion_matrix, roc_curve, auc
from sklearn import metrics
#import lightgbm 
from lightgbm import *

from xgboost import XGBClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import BaggingClassifier, RandomForestClassifier
from sklearn.naive_bayes import GaussianNB
import lightgbm as lgb

import matplotlib.pyplot as plt
import seaborn as sns
sns.set(font_scale=1.5)

from src.data_constants import *

import itertools

def read_device_pickle(iot_device_num):
    """
        Function: check_device_pickle
        input: device_name 
        Action: If a pickle file of the device object exsist in data_prep directory deserialize iot object and return or return None
    """
    
    file_name = '../../data_prep/'+IOT_DEVICES[iot_device_num][2]+".pkl"
    if os.path.exists(file_name):
        pickle_file = open(file_name, 'rb')
        iot = pickle.load(pickle_file)
        pickle_file.close()
    else:
        iot = None
    return iot

def write_device_pickle(iot_class_obj, iot_device_num):
    # create a pickle file
    pkl_file_name = '../../data_prep/'+IOT_DEVICES[iot_device_num][2]+".pkl"
    pickle_file = open(pkl_file_name, 'wb')
    
    # pickle iot object for the device and write to it.
    pickle.dump(iot_class_obj, pickle_file)
    pickle_file.close()
    
def list_iot_devices():
    # List of all IoT devices for which data was collcted
    device_list = {"Door_Bell": {"Damini_Doorbell":1, "Ennino_Doorbell":2},
               "Thermostats": {"Ecobee_Thermostat":1},
               "Baby_Monitor": {"Philips_B120N10_Baby_Monitor":1},
               "Security_Camera": {"Provision_PT_737E_Security_Camera":1,
                                   "Provision_PT_838_Security_Camera":2,
                                   "SimpleHome_XCS7_1002_WHT_Security_Camera":3,
                                   "SimpleHome_XCS7_1003_WHT_Security_Camera":4}}
   
    print("{:<17} {:<41} {:<60}".format('_______________','________________________________________','______'))
    print("{:<17} {:<41} {:<60}".format('Decice Category','Device','Number'))
    print("{:<17} {:<41} {:<60}".format('_______________','________________________________________','______'))
    
    for device,iots in device_list.items():
        for iot,val in device_list[device].items():
            print("{:<17} {:<41} {:<60}".format(device, iot, val)) 
    return device_list

def make_confusion_matrix(cf,
              group_names=None,
              categories='auto',
              count=True,
              percent=True,
              cbar=True,
              xyticks=True,
              xyplotlabels=True,
              sum_stats=True,
              figsize=None,
              cmap='coolwarm',
              title=None):
    '''
    This function will make a pretty plot of an sklearn Confusion Matrix cm using a Seaborn heatmap visualization.
    Arguments
    ---------
    cf:            confusion matrix to be passed in
    group_names:   List of strings that represent the labels row by row to be shown in each square.
    categories:    List of strings containing the categories to be displayed on the x,y axis. Default is 'auto'
    count:         If True, show the raw number in the confusion matrix. Default is True.
    normalize:     If True, show the proportions for each category. Default is True.
    cbar:          If True, show the color bar. The cbar values are based off the values in the confusion matrix.
                   Default is True.
    xyticks:       If True, show x and y ticks. Default is True.
    xyplotlabels:  If True, show 'True Label' and 'Predicted Label' on the figure. Default is True.
    sum_stats:     If True, display summary statistics below the figure. Default is True.
    figsize:       Tuple representing the figure size. Default will be the matplotlib rcParams value.
    cmap:          Colormap of the values displayed from matplotlib.pyplot.cm. Default is 'Blues'
                   See http://matplotlib.org/examples/color/colormaps_reference.html
                   
    title:         Title for the heatmap. Default is None.
    '''


    # CODE TO GENERATE TEXT INSIDE EACH SQUARE
    blanks = ['' for i in range(cf.size)]

    if group_names and len(group_names)==cf.size:
        group_labels = ["{}\n".format(value) for value in group_names]
    else:
        group_labels = blanks

    if count:
        group_counts = ["{0:0.0f}\n".format(value) for value in cf.flatten()]
    else:
        group_counts = blanks

    if percent:
        group_percentages = ["{0:.2%}".format(value) for value in cf.flatten()/np.sum(cf)]
    else:
        group_percentages = blanks

    box_labels = [f"{v1}{v2}{v3}".strip() for v1, v2, v3 in zip(group_labels,group_counts,group_percentages)]
    box_labels = np.asarray(box_labels).reshape(cf.shape[0],cf.shape[1])


    # Generate Summary Stats
    if sum_stats:
        #Accuracy is sum of diagonal divided by total observations
        accuracy  = np.trace(cf) / float(np.sum(cf))

        #if it is a binary confusion matrix, show some more stats
        if len(cf)==2:
            #Metrics for Binary Confusion Matrices
            precision = cf[1,1] / sum(cf[:,1])
            recall    = cf[1,1] / sum(cf[1,:])
            f1_score  = 2*precision*recall / (precision + recall)
            stats_text = "\n\nAccuracy={:0.3f}\nPrecision={:0.3f}\nRecall={:0.3f}\nF1 Score={:0.3f}".format(
                accuracy,precision,recall,f1_score)
        else:
            stats_text = "\n\nAccuracy={:0.3f}".format(accuracy)
    else:
        stats_text = ""


    # SET FIGURE PARAMETERS ACCORDING TO OTHER ARGUMENTS
    if figsize==None:
        #Get default figure size if not set
        figsize = plt.rcParams.get('figure.figsize')

    if xyticks==False:
        #Do not show categories if xyticks is False
        categories=False


    # MAKE THE HEATMAP VISUALIZATION
    fig = plt.figure(figsize=figsize)
    sns.heatmap(cf,annot=box_labels,fmt="",cmap=cmap,cbar=cbar,xticklabels=categories,yticklabels=categories)
        
    if xyplotlabels:
        plt.ylabel('True label')
        plt.xlabel('Predicted label' + stats_text)
    else:
        plt.xlabel(stats_text)
    
    if title:
        plt.title(title)
    fig.savefig("../../visualization/"+title+".png")
    plt.show()
    

class IoT_Device:
    '''


    '''

    
    def __init__(self,device):  
        
        global IOT_DEVICES

        self.y = None
        self.X = None
        self.device_type = IOT_DEVICES[device][0]
        self.device_num = IOT_DEVICES[device][1]
        self.device_name = IOT_DEVICES[device][2]      
        self.device = device   
        self.iot_dataframe(self.device_name)

    def create_df (self, filename):
        '''
            Method: Create_df
            Input: filename, device
            Action: Read filename and return datafram
        '''
   
    def iot_read_botnet_file(self, filename):
        '''
            Action: Read filename and return Dash dataframe        
        '''
        df = pd.DataFrame()
        if os.path.exists(filename):
            df = pd.read_csv(filename)
            file_found = True
        else:
            print("File Missing: ", filename)
            file_found = False
        return df, file_found
    
    def iot_dataframe(self, device_name):

        device_type = self.device_type   # IOT_device_type
        device_num = self.device_num
        device_name = self.device_name

        # Read benign traffic for the device
        benign_data_file = "../../data/"+ device_name +"/benign_traffic.csv"

        # Create empty dask dataframes 
        df_all = pd.DataFrame()
        df_benign = pd.DataFrame()
        df_mirai = pd.DataFrame()
        df_gafgyt = pd.DataFrame()
        df_temp = pd.DataFrame()

        #Benign dataframe
        df_temp,ff = self.iot_read_botnet_file(benign_data_file)
        df_temp['Class'] = BENIGN
        df_temp['Device'] = device_num
        df_temp["Device_Type"] = device_type
        df_temp["Traffic_Type"] = BENIGN

        # Append benign dataframe for this device to a huge benign dataframe
        df_benign = df_benign.append(df_temp)

        '''
            For the device, create mirai dataframes for ack, scan, syn, udp, 
            udpplain attack dataframes
        '''
        # Mirai file path for each device
        mirai_path = "../../data/"+ device_name +"/mirai_attacks/"

        # 1. ack.csv
        fn = mirai_path+"ack.csv"
        df_temp, ff = self.iot_read_botnet_file(fn)
        if ff: 
            df_temp['Class'] = MIRAI
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = MIRAI_ACK
            df_mirai = df_mirai.append(df_temp)
        #2 scan.csv    
        fn = mirai_path+"scan.csv"
        df_temp, ff = self.iot_read_botnet_file(fn)
        if ff: 
            df_temp['Class'] = MIRAI
            df_temp['Device'] = device_num
            df_temp['Device_Type'] = device_type
            df_temp['Traffic_Type'] = MIRAI_SCAN
            df_mirai = df_mirai.append(df_temp)       

        #3 syn.csv    
        fn = mirai_path+"syn.csv"        
        df_temp, ff = self.iot_read_botnet_file(fn)       
        if ff: 
            df_temp['Class'] = MIRAI
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = MIRAI_SYN
            df_mirai = df_mirai.append(df_temp)

        #4 udp.csv    
        fn = mirai_path+"udp.csv"
        df_temp, ff = self.iot_read_botnet_file(fn) 
        if ff: 
            df_temp['Class'] = MIRAI
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = MIRAI_UDP
            df_mirai = df_mirai.append(df_temp)

        #5 udpplain.csv    
        fn = mirai_path+"udpplain.csv"
        df_temp,ff  = self.iot_read_botnet_file(fn) 
        if ff: 
            df_temp['Class'] = MIRAI
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = MIRAI_UDPPLAIN
            df_mirai = df_mirai.append(df_temp)
            
        '''
            For the device, create gafgyt attack dataframes for combo, junk, scan, tcp and udp attack dataframes
        '''
        gafgyt_path = "../../data/"+ device_name +"/gafgyt_attacks/"

        # 1. combo.csv
        fn = gafgyt_path+"combo.csv"
        df_temp, ff = self.iot_read_botnet_file(fn) 
        if ff: 
            df_temp['Class'] = BASHLITE
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = BASHLITE_COMBO
            df_gafgyt = df_gafgyt.append(df_temp)

        #2 junk.csv    
        fn = gafgyt_path+"junk.csv"

        df_temp,ff = self.iot_read_botnet_file(fn) 
        if ff: 
            df_temp['Class'] = BASHLITE
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = BASHLITE_JUNK
            df_gafgyt = df_gafgyt.append(df_temp)

        #3 scan.csv    
        fn = gafgyt_path+"scan.csv"
        df_temp, ff = self.iot_read_botnet_file(fn) 
        if ff: 
            df_temp['Class'] = BASHLITE
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = BASHLITE_SCAN
            df_gafgyt = df_gafgyt.append(df_temp)

        #4 tcp.csv    
        fn = gafgyt_path+"tcp.csv"
        df_temp, ff = self.iot_read_botnet_file(fn) 
        if ff: 
            df_temp['Class'] = BASHLITE
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = BASHLITE_TCP
            df_gafgyt = df_gafgyt.append(df_temp)

        #5 udp.csv    
        fn = gafgyt_path+"udp.csv"
        df_temp,ff = self.iot_read_botnet_file(fn) 
        if ff: 
            df_temp['Class'] = BASHLITE
            df_temp["Device"] = device_num
            df_temp["Device_Type"] = device_type
            df_temp["Traffic_Type"] = BASHLITE_UDP
            df_gafgyt = df_gafgyt.append(df_temp)

        count_benign = df_benign.shape[0]
        count_mirai = df_mirai.shape[0]
        count_gafgyt = df_gafgyt.shape[0]
       
        # Instead of running ~7.5GB datafile, I will create a dataset with the following logic
        # 1) Select 50% benign and 50% malware traffic for use in all models
        # 2) 1/2 of the malware traffic is equally split between Mirak and Bashlite       
        # 3) ically 1/4+1/4= 1/2 as decided earlier

        df_mirai = df_mirai.sample(n=int((1/4)*len(df_benign)), replace=False, random_state=2)
        df_gafgyt = df_gafgyt.sample(n=int((1/4)*len(df_benign)), replace=False, random_state=42)                      
        df_all = pd.concat([df_benign, df_mirai, df_gafgyt], ignore_index=True)
        
        # Shuffle the dataframe before running models
        df_all = df_all.sample(frac=1).reset_index(drop=True)      
        
        self.y = df_all['Class']
        self.X = df_all.drop('Class', axis=1)
        self.device_type = device_type
        self.device_num = device_num
        self.device_name = device_name

        print("Ready to pickle the device ..  Shape: {}".format(len(self.y))) 
           
    def iot_confusion_matrix(self, print_train, y_test, y_hat_test, title_test, y_train=None, y_hat_train=None, title_train=None):
        '''
            This method will print confustion matrix for both train and test sets
        '''
        cm_train = cm_test = None
        # Run confustion_matric with the predicted value and the test set
        if print_train == True:
            cm_train = confusion_matrix(y_train, y_hat_train) 
            make_confusion_matrix(cm_train, figsize=(8,6), categories=["Benign", "Mirai", "Gafgyt"], cbar=False, title=title_train, sum_stats=True)

        # Run confustion_matric with the predicted value and the test set
        cm_test = confusion_matrix(y_test, y_hat_test)
        make_confusion_matrix(cm_test, figsize=(8,6), categories=["Benign", "Mirai", "Gafgyt"], cbar=False, title=title_test, sum_stats=True)
        return cm_test, cm_train
    
    def iot_roc_curve(self, fpr, tpr, title):
        # Seaborn's beautiful styling
        sns.set_style('darkgrid', {'axes.facecolor': '0.9'})

        print('AUC: {}'.format(auc(fpr, tpr)))
        plt.figure(figsize=(10, 8))
        lw = 2
        plt.plot(fpr, tpr, color='darkorange',
                 lw=lw, label='ROC curve')
        plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.yticks([i/20.0 for i in range(21)])
        plt.xticks([i/20.0 for i in range(21)])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title(title)
        plt.legend(loc='lower right')
        plt.show()
                                                         
    def iot_Fit_Predict_Report(self, model, model_name,  X_train_ss, X_test_ss, y_train, y_test):
        # Fit Model
        model.fit(X_train_ss, y_train)
        
        # Predict and Report
        y_hat_train = model.predict(X_train_ss)
        y_hat_test = model.predict(X_test_ss)

        # print classification report to out put recall, precision, accuacy and F1 scores
        print(classification_report(y_test, y_hat_test))

        # print confustion_matric with the predicted values for test and train data
        title_test = "[" + self.device_name + "] [Validation Data] " + model_name
        title_train ="[" + self.device_name + "] [Train Data] " + model_name

        # Store the model and results as a class variable
        test_cm, train_cm = self.iot_confusion_matrix( True, y_test, y_hat_test, title_test, y_train, y_hat_train, title_train )
        
        # Predict on training and test sets
        train_prediction  = model.predict(X_train_ss)
        test_prediction  = model.predict(X_test_ss)         
        
        return  train_cm, test_cm, y_hat_train, y_hat_test
        
    def iot_Model(self, model_name): 
        '''
            IoT_FSM method will perform a first simple model with LogisticRegression with all default parameters, except max_iter=1000 otherwise cpu is going crazy
            
            Method: IoT_FSM
            Input: "FSM", "LogisticRegression", "KNeighborsClassifier", "DecisionTreeClassifier", "RandomForestClassifer"
            Action: 1) Change target to binary, for FSM only.
                    2) Instantiate LogisticRegression classifier
                    3) Fit model
                    4) Run cross_val_score
        '''   
        if model_name == "DummyClassifier":
            '''
                DummyClassifier is a classifier that makes predictions using simple rules.
                This classifier is useful as a simple baseline to compare with other (real) classifiers.
                Use of strategy 'stratified' reflects the use of the class distribution
            '''
            dummy_model = DummyClassifier(strategy="stratified", random_state=42)
            dummy_model.fit(self.X, self.y)
            y_hat = dummy_model.predict(self.X)
            
            # print classification report to out put recall, precision, accuacy and F1 scores
            print(classification_report(self.y, y_hat))
                    
            self.dummy_model_cross_val_score = cross_val_score(dummy_model, self.X, self.y, cv=5)
            print(f"\n [{self.device}] Dummy Model: Raw Input Data--cross_val_score-", self.dummy_model_cross_val_score)
            title_test = "[" + self.device_name + "] [Test Data] "+ model_name
            title_train=""
            
            self.dummy_test_cm, self.dummy_train_cm = self.iot_confusion_matrix(False, self.y, y_hat, title_test, None, None, None)       

        elif model_name == "FSM":
#             '''
#                 For First Simple Model, we will LogisticRegression.
#                 However, we will use the entire dataset without split.
#             '''
#             ss = StandardScaler()
#             X_ss = ss.fit_transform(self.X)
            
#             fsm = LogisticRegression()
#             fsm.fit(X_ss,self.y)
            
#             y_hat = fsm.predict(self.X)
            
#             title_test = "[" + self.device_name + "] [Test Data] FSM-LogisticRegression"
#             title_train =""
            
#             # print classification report to out put recall, precision, accuacy and F1 scores
#             print(classification_report(self.y, y_hat))  
            
#             # Call iot_confusion_matrix  to print confustion matrix
#             self.fsm_test_cm, self.fsm_train_cm = self.iot_confusion_matrix(False, self.y, y_hat, title_test, None, None, None)
#             self.fsm_model = fsm                      
            
#             # Cross Validation Score
#             self.fsm_cross_val_score = cross_val_score(fsm, self.X, self.y, cv=5)
#             print(f"\n [{self.device}] FSM Model: Raw Input Data--cross_val_score-", self.fsm_cross_val_score)
            '''
                For First Simple Model, we will LogisticRegression.
                However, we will use the entire dataset without split.
            '''
#           ss = StandardScaler()
#           X_ss = ss.fit_transform(self.X)
            
            fsm = LogisticRegression()
            fsm.fit(self.X, self.y)
            
            y_hat = fsm.predict(self.X)
            
            title_test = "[" + self.device_name + "] [Test Data] FSM-LogisticRegression"
            title_train =""
            
            # print classification report to out put recall, precision, accuacy and F1 scores
            print(classification_report(self.y, y_hat))  
            
            # Call iot_confusion_matrix  to print confustion matrix
            self.fsm_test_cm, self.fsm_train_cm = self.iot_confusion_matrix(False, self.y, y_hat, title_test, None, None, None)
            self.fsm_model = fsm                      
            
            # Cross Validation Score
            self.fsm_cross_val_score = cross_val_score(fsm, self.X, self.y, cv=5)
            print(f"\n [{self.device}] FSM Model: Raw Input Data--cross_val_score-", self.fsm_cross_val_score)            

        else:           
                    '''
                        We will do the following here.
                        1) Split the data and keep aside 30% if test data for final testing.
                        2) Do a secondary split on the remaining 70% data with train and validation dataset for model turning.
                    '''
                
                    # Train test split - to hold out 30% of test data for validating the model
                    X_train, X_test, y_train, y_test = train_test_split(self.X, self.y, test_size=0.30, random_state=42)
                    
                    # Store X_test and y_test in the IoT_Device class for final model testing
                    self.X_test = X_test
                    self.y_test = y_test
                    
                    # Do a secondary split - for training model with 30% validation dataset
                    X_train_tt, X_val_tt, y_train_tt, y_val_tt = train_test_split(X_train, y_train, test_size=0.30, random_state=42)
                    
#                     #Standardize data
#                     ss = StandardScaler()
                                
#                     # Apply transform to both the training set and the test set.
#                     X_train_tt_ss = ss.fit_transform(X_train_tt)
#                     X_val_tt_ss  = ss.transform(X_val_tt)

                    if model_name == "LogisticRegression":
                        '''
                        We will do the following here.
                        1) LogisticRegression on the training and validation set
                        2) Creeate Confution Matrix with the training and test results
                        '''
                        # Istantiate Logistic Regression classifier
                        lg = LogisticRegression(random_state=42)
                
#                         # Fit and Predict Model
#                         self.lg_train_cm, self.lg_val_cm, self.lg_train_prediction, self.lg_val_prediction = \
#                             self.iot_Fit_Predict_Report(lg, model_name, X_train_tt_ss, X_val_tt_ss, y_train_tt, y_val_tt)
#                         self.lg_model =lg
                        
#                         # Finally, print confusion maxtrix of test data
#                         X_test_ss  = ss.transform(X_test)
#                         y_hat_test = lg.predict(X_test_ss)
#                         title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
#                         test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
#                         self.lg_test_prediction = y_hat_test

#                         # Fit and Predict Model
#                         self.lg_train_cm, self.lg_val_cm, self.lg_train_prediction, self.lg_val_prediction = \
#                             self.iot_Fit_Predict_Report(lg, model_name, X_train_tt_ss, X_val_tt_ss, y_train_tt, y_val_tt)
#                         self.lg_model =lg

                        # Fit and Predict Model
                        self.lg_train_cm, self.lg_val_cm, self.lg_train_prediction, self.lg_val_prediction = \
                            self.iot_Fit_Predict_Report(lg, model_name, X_train_tt, X_val_tt, y_train_tt, y_val_tt)
                        self.lg_model =lg
                        
                        # Finally, print confusion maxtrix of test data
#                        X_test_ss  = ss.transform(X_test)
                        y_hat_test = lg.predict(X_test)
                        title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
                        test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
                        self.lg_test_prediction = y_hat_test

                        # Fit and Predict Model
                        self.lg_train_cm, self.lg_val_cm, self.lg_train_prediction, self.lg_val_prediction = \
                            self.iot_Fit_Predict_Report(lg, model_name, X_train_tt, X_val_tt, y_train_tt, y_val_tt)
                        self.lg_model =lg
                        

                    elif model_name ==  "KNeighborsClassifier":
#                         '''
#                         We will do the following here.
#                         1) KNeighborsClassifier on the training and validation set
#                         2) Creeate Confution Matrix with the training and test results
#                         '''
#                         knn = KNeighborsClassifier(10, n_jobs=4)
                
#                         # Fit and Predict Model
#                         self.knn_train_cm, self.knn_val_cm, self.knn_train_prediction, self.knn_val_prediction = \
#                             self.iot_Fit_Predict_Report(knn, model_name, X_train_tt_ss, X_val_tt_ss, y_train_tt, y_val_tt)
#                         self.knn_model =knn
                        
#                         # Finally, print confusion maxtrix of test data
#                         X_test_ss  = ss.transform(X_test)
#                         y_hat_test = knn.predict(X_test_ss)
#                         title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
#                         test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
#                         self.knn_test_prediction = y_hat_test
                        
                        '''
                        We will do the following here.
                        1) KNeighborsClassifier on the training and validation set
                        2) Creeate Confution Matrix with the training and test results
                        '''
                        knn = KNeighborsClassifier(10, n_jobs=4)
                
                        # Fit and Predict Model
                        self.knn_train_cm, self.knn_val_cm, self.knn_train_prediction, self.knn_val_prediction = \
                            self.iot_Fit_Predict_Report(knn, model_name, X_train_tt, X_val_tt, y_train_tt, y_val_tt)
                        self.knn_model =knn
                        
                        # Finally, print confusion maxtrix of test data
#                        X_test_ss  = ss.transform(X_test)
                        y_hat_test = knn.predict(X_test)
                        title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
                        test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
                        self.knn_test_prediction = y_hat_test                  
                    elif model_name == "DecisionTreeClassifier":
#                         '''
#                         We will do the following here.
#                         1) DecisionTreeClassifier on the training and validation set
#                         2) Creeate Confution Matrix with the training and test results
#                         '''
#                         dt = DecisionTreeClassifier(random_state = 42)
                        
#                         # Fit and Predict Model
#                         self.dt_train_cm, self.dt_val_cm, self.dt_train_prediction, self.dt_val_prediction = \
#                             self.iot_Fit_Predict_Report(dt, model_name, X_train_tt_ss, X_val_tt_ss, y_train_tt, y_val_tt)
#                         self.dt_model = dt
                        
#                         # Finally, print confusion maxtrix of test data
#                         X_test_ss  = ss.transform(X_test)
#                         y_hat_test = dt.predict(X_test_ss)
#                         title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
#                         test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
#                         self.dt_test_prediction = y_hat_test
                        dt = DecisionTreeClassifier(random_state = 42)
                        
                        # Fit and Predict Model
                        self.dt_train_cm, self.dt_val_cm, self.dt_train_prediction, self.dt_val_prediction = \
                            self.iot_Fit_Predict_Report(dt, model_name, X_train_tt, X_val_tt, y_train_tt, y_val_tt)
                        self.dt_model = dt
                        
                        # Finally, print confusion maxtrix of test data
#                        X_test_ss  = ss.transform(X_test)
                        y_hat_test = dt.predict(X_test)
                        title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
                        test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
                        self.dt_test_prediction = y_hat_test              
                        

                    elif model_name == "RandomForestClassifer":  
#                         '''
#                         We will do the following here.
#                         1) RandomForest on the training and validation set
#                         2) Creeate Confution Matrix with the training and test results
#                         '''
#                         # Instantiate XGBClassifier
#                         rfc = RandomForestClassifier(random_state=42)
                
#                         # Fit and Predict Model
#                         self.rfc_train_cm, self.rfc_val_cm, self.rfc_train_prediction, self.rfc_val_prediction = \
#                             self.iot_Fit_Predict_Report(rfc, model_name, X_train_tt_ss, X_val_tt_ss, y_train_tt, y_val_tt)
#                         self.rfc_model = rfc   
#                         # Finally, print confusion maxtrix of test data
#                         X_test_ss  = ss.transform(X_test)
#                         y_hat_test = rfc.predict(X_test_ss)
#                         title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
#                         test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
#                         self.rfc_test_prediction = y_hat_test
                        '''
                        We will do the following here.
                        1) RandomForest on the training and validation set
                        2) Creeate Confution Matrix with the training and test results
                        '''
                        # Instantiate XGBClassifier
                        rfc = RandomForestClassifier(random_state=42)
                
                        # Fit and Predict Model
                        self.rfc_train_cm, self.rfc_val_cm, self.rfc_train_prediction, self.rfc_val_prediction = \
                            self.iot_Fit_Predict_Report(rfc, model_name, X_train_tt, X_val_tt, y_train_tt, y_val_tt)
                        self.rfc_model = rfc   
                        # Finally, print confusion maxtrix of test data
#                       X_test_ss  = ss.transform(X_test)
                        y_hat_test = rfc.predict(X_test)
                        title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
                        test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
                        self.rfc_test_prediction = y_hat_test
                    elif model_name == "XGBClassifier":
#                         '''
#                         We will do the following here.
#                         1) RandomForest on the training and validation set
#                         2) Creeate Confution Matrix with the training and test results
#                         '''
#                         # Instantiate XGBClassifier
#                         xgb = XGBClassifier(random_state=42)
                
#                         # Fit and Predict Model
#                         self.xgb_train_cm, self.xgb_val_cm, self.xgb_train_prediction, self_xgb_val_prediction = \
#                             self.iot_Fit_Predict_Report(xgb, model_name, X_train_tt_ss, X_val_tt_ss, y_train_tt, y_val_tt)
#                         self.xgb_model = xgb 
                        
#                         #Finally, print confusion maxtrix of test data
#                         X_test_ss  = ss.transform(X_test)
#                         y_hat_test = xgb.predict(X_test_ss)
#                         title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
#                         test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
#                         self.xgb_test_prediction = y_hat_test
                        '''
                        We will do the following here.
                        1) RandomForest on the training and validation set
                        2) Creeate Confution Matrix with the training and test results
                        '''
                        # Instantiate XGBClassifier
                        xgb = XGBClassifier(random_state=42)
                
                        # Fit and Predict Model
                        self.xgb_train_cm, self.xgb_val_cm, self.xgb_train_prediction, self_xgb_val_prediction = \
                            self.iot_Fit_Predict_Report(xgb, model_name, X_train_tt, X_val_tt, y_train_tt, y_val_tt)
                        self.xgb_model = xgb 
                        
                        #Finally, print confusion maxtrix of test data
#                       X_test_ss  = ss.transform(X_test)
                        y_hat_test = xgb.predict(X_test)
                        title_test = "[" + self.device_name + "] [Final Test Data] " + model_name
                        test_cm, train_cm = self.iot_confusion_matrix( False, y_test, y_hat_test, title_test)
                        self.xgb_test_prediction = y_hat_test
                    else:
                        Print("Incorrect model. Refer to iot.iot_Model_")
    
                        
    def iot_precision(self, y, y_hat):
        '''
            Method: iot_precision
            Calculate Precision
        '''
        # Could also use confusion matrix
        y_y_hat = list(zip(y, y_hat))
        tp = sum([1 for i in y_y_hat if i[0] == 1 and i[1] == 1])
        fp = sum([1 for i in y_y_hat if i[0] == 0 and i[1] == 1])
        return tp / float(tp + fp)
    
    def iot_recall(self, y, y_hat):
        '''
            Method: iot_recall
            Calculate Recall
        '''
        y_y_hat = list(zip(y, y_hat))
        tp = sum([1 for i in y_y_hat if i[0] == 1 and i[1] == 1])
        fn = sum([1 for i in y_y_hat if i[0] == 1 and i[1] == 0])
        return tp / float(tp + fn)    
    
    def iot_accuracy(self, y, y_hat):
        '''
            Method: iot_accuracy
            Calculate Accuracy
        '''
        y_y_hat = list(zip(y, y_hat))
        tp = sum([1 for i in y_y_hat if i[0] == 1 and i[1] == 1])
        tn = sum([1 for i in y_y_hat if i[0] == 0 and i[1] == 0])
        return (tp + tn) / float(len(y_hat))
    
    def iot_f1(self, y, y_hat):
        '''
            Method: iot_f1
            Calculate F1
        '''
        precision_score = precision(y, y_hat)
        recall_score = recall(y, y_hat)
        numerator = precision_score * recall_score
        denominator = precision_score + recall_score
        return 2 * (numerator / denominator)   
  
    def accuracy(self,  confusion_matrix):
        diagonal_sum = confusion_matrix.trace()
        sum_of_all_elements = confusion_matrix.sum()
        return diagonal_sum / sum_of_all_elements 

    def recall(self, label, confusion_matrix):
        row = confusion_matrix[label, :]
        return confusion_matrix[label, label] / row.sum()
    
    def precision(self, label, confusion_matrix):
        col = confusion_matrix[:, label]
        return confusion_matrix[label, label] / col.sum()
    
    def recall_macro_average(self, confusion_matrix):
        rows, columns = confusion_matrix.shape
        sum_of_recalls = 0
        for label in range(columns):
            sum_of_recalls += self.recall(label, confusion_matrix)
        return sum_of_recalls / columns

    def iot_compare_recall_accuracy(self, test): 

        training_recall_benign = []
        training_recall_mirai = []
        training_recall_gafgyt = []
        testing_recall_benign = []
        testing_recall_mirai = []
        testing_recall_gafgyt = []      
        testing_recall_macro_average = []
        training_recall_macro_average = []
        training_accuracy = []
        testing_accuracy =[]


        for i in range(70, 100):
            print("Iteration = ",i)
            X_train, X_test, y_train, y_test = train_test_split(self.X, self.y, test_size=i/100.0)
            
            if test == "LogisticRegression":
                model = LogisticRegression(fit_intercept=False, C=1e25, solver='liblinear')
            elif test == "KNeighborsClassifier":
                model = KNeighborsClassifier(3, n_jobs=4)
                
            model = model.fit(X_train, y_train)
            
            y_hat_test = model.predict(X_test)
            y_hat_train = model.predict(X_train)
            
            cm_test = confusion_matrix(y_test, y_hat_test)
            cm_train = confusion_matrix(y_train, y_hat_train)

            for i in [0,1,2]:
                training_recall_benign.append(self.recall(i, cm_train))
                testing_recall_benign.append(self.recall(i, cm_test))  
                training_recall_mirai.append(self.recall(i, cm_train))
                testing_recall_mirai.append(self.recall(i, cm_test))                
                training_recall_mirai.append(self.recall(i, cm_train))
                testing_recall_mirai.append(self.recall(i, cm_test))                  
                training_recall_gafgyt.append(self.recall(i, cm_train))
                testing_recall_gafgyt.append(self.recall(i, cm_test))  
            testing_recall_macro_average.append(self.recall_macro_average(cm_test))
            training_recall_macro_average.append(self.recall_macro_average(cm_train))            

            training_accuracy.append(self.accuracy(cm_train))
            testing_accuracy.append(self.accuracy(cm_train))
#         # https://www.python-course.eu/confusion_matrix.php
            
#         Train and test recall_benign
        plt.scatter(list(range(0,90)), training_recall_benign, label='training_recall_benign')
        plt.scatter(list(range(0,90)), testing_recall_benign, label='testing_recall_benign')
        plt.scatter(list(range(0,90)), testing_recall_mirai, label='training_recall_mirai')
        plt.scatter(list(range(0,90)), testing_recall_mirai, label='testing_recall_mirai')
        plt.scatter(list(range(0,90)), testing_recall_gafgyt, label='training_recall_gafgyt')
        plt.scatter(list(range(0,90)), testing_recall_gafgyt, label='testing_recall_gafgyt')   
        plt.scatter(list(range(0,30)), training_accuracy, label='training_accuracy')
        plt.scatter(list(range(0,30)), testing_accuracy, label='testing_accuracy')         
        
        plt.legend()
        plt.show()

